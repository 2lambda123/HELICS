/*
Copyright (C) 2017, Battelle Memorial Institute
All rights reserved.

This software was co-developed by Pacific Northwest National Laboratory, operated by the Battelle Memorial
Institute; the National Renewable Energy Laboratory, operated by the Alliance for Sustainable Energy, LLC; and the
Lawrence Livermore National Laboratory, operated by Lawrence Livermore National Security, LLC.

*/
#ifndef _HELICS_FILTER_H_
#define _HELICS_FILTER_H_
#pragma once

#include "MessageFilterFederate.h"
#include "MessageOperators.h"

namespace helics
{
	class FilterOperations
	{
	public:
		FilterOperations() = default;
		virtual ~FilterOperations() = default;
		virtual void set(const std::string &property, double val)=0;
		virtual void setString(const std::string &property, const std::string &val) = 0;
	};

	class delayFilterOperation :public FilterOperations
	{
	private:
		Time delay = timeZero;
			MessageTimeOperator td;
	public:
		delayFilterOperation(Time delayTime = timeZero);
		virtual void set(const std::string &property, double val) override;
		virtual void setString(const std::string &property, const std::string &val) override;
		
	};

	class randomDelayGenerator;

	class randomDelayFilterOperation :public FilterOperations
	{
	private:
		Time delay = timeZero;
		MessageTimeOperator td;
		std::unique_ptr<randomDelayGenerator> rdelayGen;
	public:
		randomDelayFilterOperation();
		~randomDelayFilterOperation();
		virtual void set(const std::string &property, double val) override;
		virtual void setString(const std::string &property, const std::string &val) override;

	};

class Filter
{
  protected:
    MessageFilterFederate *fed = nullptr;  //!< the MessageFederate to interact with
    filter_id_t id = invalid_id_value;  //!< the id as generated by the Federate
	std::shared_ptr<FilterOperations> filtOp;  //!< a class running any specific operation of the Filter
  public:
	  Filter() = default;
	  Filter(MessageFilterFederate *mfed) :fed(mfed)
	  {};
    virtual ~Filter () = default;

    /** set a message operator to process the message*/
    void setOperator (std::shared_ptr<MessageOperator> mo)
    {
        if (fed != nullptr)
        {
            fed->registerMessageOperator (id, std::move (mo));
        }
    }


};
/** class wrapping a source filter*/
class SourceFilter:public Filter
{
  public:
    /**constructor to build an source filter object
    @param[in] mFed  the MessageFederate to use
    @param[in] target the endpoint the filter is targeting
    @param[in] name the name of the filter
    @param[in] input_type the type of data the filter is expecting
    @param[in] output_type the type of data the filter is generating
    */
    SourceFilter (MessageFilterFederate *mFed,
                  const std::string &target,
                  const std::string &name = "",
                  const std::string &input_type = "",
                  const std::string &output_type = "")
        : Filter(mFed)
    {
        id = fed->registerSourceFilter (name, target, input_type, output_type);
    }

    virtual ~SourceFilter () = default;

    auto getMessage () const { return fed->getMessageToFilter (id); }
    /** check if there is a message available*/
    bool hasMessage () const { return fed->hasMessageToFilter (id); }

    /** register a callback for an update notification
    @details the callback is called in the just before the time request function returns
    @param[in] callback a function with signature void(endpoint_id_t, Time)
    time is the time the value was updated  This callback is a notification callback and doesn't return the value
    */
    void setCallback (std::function<void(filter_id_t, Time)> callback)
    {
        fed->registerFilterCallback (id, callback);
    }
};

/** class wrapping a destination filter*/
class DestinationFilter:public Filter
{
  public:
    /**constructor to build an destination filter object
    @param[in] mFed  the MessageFederate to use
    @param[in] target the endpoint the filter is targeting
    @param[in] name the name of the filter
    @param[in] input_type the type of data the filter is expecting
    @param[in] output_type the type of data the filter is generating
    */
    DestinationFilter (MessageFilterFederate *mFed,
                       const std::string &target,
                       const std::string &name = "",
                       const std::string &input_type = "",
                       const std::string &output_type = "")
        :Filter (mFed)
    {
        id = fed->registerDestinationFilter (name, target, input_type, output_type);
    }
    virtual ~DestinationFilter () = default;

};

enum defined_filter_types
{
    custom = 0,
    delay = 1,
    randomDelay = 2,
    randomDrop = 3,
};

std::unique_ptr<DestinationFilter> make_destination_filter (defined_filter_types type,
                                                            MessageFilterFederate *mFed,
                                                            const std::string &target,
                                                            const std::string &name = "");

std::unique_ptr<SourceFilter> make_Source_filter (defined_filter_types type,
                                                  MessageFilterFederate *mFed,
                                                  const std::string &target,
                                                  const std::string &name = "");

}  // namespace helics
#endif
